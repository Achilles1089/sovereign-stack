package docker

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Achilles1089/sovereign-stack/internal/config"
	"gopkg.in/yaml.v3"
)

// ComposeService represents a Docker Compose service definition
type ComposeService struct {
	Image         string            `yaml:"image"`
	ContainerName string            `yaml:"container_name"`
	Restart       string            `yaml:"restart"`
	Ports         []string          `yaml:"ports,omitempty"`
	Volumes       []string          `yaml:"volumes,omitempty"`
	Environment   []string          `yaml:"environment,omitempty"`
	DependsOn     []string          `yaml:"depends_on,omitempty"`
	Labels        map[string]string `yaml:"labels,omitempty"`
	HealthCheck   *HealthCheck      `yaml:"healthcheck,omitempty"`
	Deploy        *DeployConfig     `yaml:"deploy,omitempty"`
	Networks      []string          `yaml:"networks,omitempty"`
}

// HealthCheck represents a Docker health check
type HealthCheck struct {
	Test     []string `yaml:"test"`
	Interval string   `yaml:"interval"`
	Timeout  string   `yaml:"timeout"`
	Retries  int      `yaml:"retries"`
}

// DeployConfig for GPU resources
type DeployConfig struct {
	Resources *Resources `yaml:"resources,omitempty"`
}

// Resources for resource reservations
type Resources struct {
	Reservations *Reservations `yaml:"reservations,omitempty"`
}

// Reservations for device reservations (GPU)
type Reservations struct {
	Devices []Device `yaml:"devices,omitempty"`
}

// Device represents a GPU device reservation
type Device struct {
	Driver       string     `yaml:"driver"`
	Count        string     `yaml:"count"`
	Capabilities [][]string `yaml:"capabilities"`
}

// ComposeFile represents the full docker-compose.yml
type ComposeFile struct {
	Version  string                     `yaml:"version,omitempty"`
	Services map[string]*ComposeService `yaml:"services"`
	Volumes  map[string]interface{}     `yaml:"volumes,omitempty"`
	Networks map[string]interface{}     `yaml:"networks,omitempty"`
}

// GenerateCoreCompose creates the core docker-compose.yml from config
func GenerateCoreCompose(cfg *config.Config) *ComposeFile {
	compose := &ComposeFile{
		Services: make(map[string]*ComposeService),
		Volumes:  make(map[string]interface{}),
		Networks: map[string]interface{}{
			"sovereign": map[string]string{"driver": "bridge"},
		},
	}

	sovLabels := map[string]string{"sovereign.managed": "true"}

	// PostgreSQL
	if cfg.Services.Postgres {
		compose.Services["postgres"] = &ComposeService{
			Image:         "postgres:16-alpine",
			ContainerName: "sovereign-postgres",
			Restart:       "unless-stopped",
			Volumes:       []string{"postgres_data:/var/lib/postgresql/data"},
			Environment: []string{
				"POSTGRES_USER=sovereign",
				"POSTGRES_PASSWORD=sovereign",
				"POSTGRES_DB=sovereign",
			},
			Labels:   sovLabels,
			Networks: []string{"sovereign"},
			HealthCheck: &HealthCheck{
				Test:     []string{"CMD-SHELL", "pg_isready -U sovereign"},
				Interval: "10s",
				Timeout:  "5s",
				Retries:  5,
			},
		}
		compose.Volumes["postgres_data"] = nil
	}

	// llama-server runs natively — no Docker container needed for AI inference

	// Caddy reverse proxy
	if cfg.Services.Caddy {
		compose.Services["caddy"] = &ComposeService{
			Image:         "caddy:2-alpine",
			ContainerName: "sovereign-caddy",
			Restart:       "unless-stopped",
			Ports:         []string{"80:80", "443:443"},
			Volumes: []string{
				"caddy_data:/data",
				"caddy_config:/config",
				config.ConfigDir() + "/Caddyfile:/etc/caddy/Caddyfile",
			},
			Labels:   sovLabels,
			Networks: []string{"sovereign"},
		}
		compose.Volumes["caddy_data"] = nil
		compose.Volumes["caddy_config"] = nil
	}

	return compose
}

// WriteComposeFile writes the compose file to disk
func WriteComposeFile(compose *ComposeFile, path string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	data, err := yaml.Marshal(compose)
	if err != nil {
		return fmt.Errorf("failed to serialize compose file: %w", err)
	}

	// Add header comment
	header := "# Sovereign Stack — Docker Compose Configuration\n# Auto-generated by 'sovereign init'. Do not edit manually.\n# To regenerate: sovereign init --force\n\n"

	if err := os.WriteFile(path, []byte(header+string(data)), 0644); err != nil {
		return fmt.Errorf("failed to write compose file: %w", err)
	}

	return nil
}

// GenerateCaddyfile creates a basic Caddyfile
func GenerateCaddyfile(cfg *config.Config) string {
	var sb strings.Builder

	sb.WriteString("# Sovereign Stack — Caddyfile\n")
	sb.WriteString("# Auto-generated by sovereign init\n\n")

	if cfg.Domain == "localhost" {
		sb.WriteString(":80 {\n")
	} else {
		sb.WriteString(cfg.Domain + " {\n")
	}

	sb.WriteString("    # Dashboard\n")
	sb.WriteString(fmt.Sprintf("    reverse_proxy /dashboard/* localhost:%d\n", cfg.Port))
	sb.WriteString("\n")
	sb.WriteString("    # Default response\n")
	sb.WriteString("    respond \"Sovereign Stack is running\" 200\n")
	sb.WriteString("}\n")

	return sb.String()
}

// WriteCaddyfile writes the Caddyfile to the sovereign config dir
func WriteCaddyfile(cfg *config.Config) error {
	path := filepath.Join(config.ConfigDir(), "Caddyfile")
	content := GenerateCaddyfile(cfg)
	return os.WriteFile(path, []byte(content), 0644)
}

// AddAppToCompose merges an app's compose service into the main compose file
func AddAppToCompose(compose *ComposeFile, appName string, service *ComposeService) {
	service.Labels = map[string]string{
		"sovereign.managed": "true",
		"sovereign.app":     appName,
	}
	service.Networks = []string{"sovereign"}
	compose.Services[appName] = service
}

// RemoveAppFromCompose removes an app from the compose file
func RemoveAppFromCompose(compose *ComposeFile, appName string) {
	delete(compose.Services, appName)
}

// LoadComposeFile reads a compose file from disk
func LoadComposeFile(path string) (*ComposeFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read compose file: %w", err)
	}

	compose := &ComposeFile{}
	if err := yaml.Unmarshal(data, compose); err != nil {
		return nil, fmt.Errorf("failed to parse compose file: %w", err)
	}

	return compose, nil
}
